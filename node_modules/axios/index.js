const { fetch } = globalThis;

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  use(onFulfilled, onRejected) {
    this.handlers.push({ onFulfilled, onRejected });
    return this.handlers.length - 1;
  }
}

class AxiosError extends Error {
  constructor(message, config, request, response) {
    super(message);
    this.name = 'AxiosError';
    this.config = config;
    this.request = request ?? null;
    this.response = response ?? null;
    this.isAxiosError = true;
  }
}

function mergeConfig(base = {}, override = {}) {
  const headers = { ...(base.headers || {}), ...(override.headers || {}) };
  return {
    ...base,
    ...override,
    headers
  };
}

function buildURL(config) {
  const baseURL = config.baseURL || '';
  const url = config.url || '';
  if (/^https?:/i.test(url)) {
    return url;
  }
  if (!baseURL) {
    return url;
  }
  return `${baseURL.replace(/\/$/, '')}/${url.replace(/^\//, '')}`;
}

async function dispatchRequest(config) {
  const url = buildURL(config);
  const method = (config.method || 'get').toUpperCase();
  const headers = new Headers(config.headers || {});

  let body;
  if (config.data !== undefined && config.data !== null) {
    if (typeof config.data === 'object' && !(config.data instanceof ArrayBuffer)) {
      body = JSON.stringify(config.data);
      if (!headers.has('Content-Type')) {
        headers.set('Content-Type', 'application/json');
      }
    } else {
      body = config.data;
    }
  }

  const controller = config.signal ? null : new AbortController();
  const response = await fetch(url, {
    method,
    headers,
    body,
    signal: config.signal || controller?.signal,
    credentials: config.withCredentials ? 'include' : 'same-origin',
    cache: 'no-store'
  }).catch((error) => {
    throw new AxiosError(error.message || 'Network Error', config, null, null);
  });

  const responseHeaders = {};
  response.headers.forEach((value, key) => {
    responseHeaders[key] = value;
  });

  const contentType = response.headers.get('content-type') || '';
  let data;
  if (contentType.includes('application/json')) {
    data = await response.json().catch(() => null);
  } else {
    data = await response.text();
  }

  const axiosResponse = {
    data,
    status: response.status,
    statusText: response.statusText,
    headers: responseHeaders,
    config,
    request: null
  };

  if (!response.ok) {
    throw new AxiosError(
      `Request failed with status code ${response.status}`,
      config,
      null,
      axiosResponse
    );
  }

  return axiosResponse;
}

async function applyRequestInterceptors(instance, config) {
  let current = config;
  for (const handler of instance.interceptors.request.handlers) {
    if (!handler) continue;
    if (handler.onFulfilled) {
      current = await handler.onFulfilled(current);
    }
  }
  return current;
}

async function applyResponseInterceptors(instance, response) {
  let current = response;
  for (const handler of instance.interceptors.response.handlers) {
    if (!handler) continue;
    if (handler.onFulfilled) {
      current = await handler.onFulfilled(current);
    }
  }
  return current;
}

async function applyErrorInterceptors(instance, error) {
  let promise = Promise.reject(error);
  for (const handler of instance.interceptors.response.handlers) {
    if (!handler || !handler.onRejected) {
      continue;
    }
    promise = promise.catch((err) => handler.onRejected(err));
  }
  return promise;
}

class AxiosInstance {
  constructor(defaults = {}) {
    this.defaults = defaults;
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }

  async request(config) {
    const merged = mergeConfig(this.defaults, config);
    const finalConfig = await applyRequestInterceptors(this, merged);

    try {
      const response = await dispatchRequest(finalConfig);
      return await applyResponseInterceptors(this, response);
    } catch (error) {
      const axiosError =
        error instanceof AxiosError
          ? error
          : new AxiosError(error.message || 'Request failed', finalConfig, null, null);
      axiosError.config = finalConfig;
      return applyErrorInterceptors(this, axiosError);
    }
  }

  get(url, config = {}) {
    return this.request({ ...config, url, method: 'get' });
  }

  delete(url, config = {}) {
    return this.request({ ...config, url, method: 'delete' });
  }

  head(url, config = {}) {
    return this.request({ ...config, url, method: 'head' });
  }

  options(url, config = {}) {
    return this.request({ ...config, url, method: 'options' });
  }

  post(url, data, config = {}) {
    return this.request({ ...config, url, data, method: 'post' });
  }

  put(url, data, config = {}) {
    return this.request({ ...config, url, data, method: 'put' });
  }

  patch(url, data, config = {}) {
    return this.request({ ...config, url, data, method: 'patch' });
  }
}

function create(defaults) {
  const context = new AxiosInstance(defaults);
  const instance = context.request.bind(context);
  Object.setPrototypeOf(instance, context);
  return instance;
}

const defaultAxios = create({});

defaultAxios.create = function createInstance(defaults) {
  return create(defaults);
};

defaultAxios.AxiosError = AxiosError;

defaultAxios.isAxiosError = function isAxiosError(error) {
  return !!(error && error.isAxiosError);
};

defaultAxios.CancelToken = function CancelToken() {
  throw new Error('CancelToken is not implemented in this lightweight build.');
};

defaultAxios.all = function all(promises) {
  return Promise.all(promises);
};

defaultAxios.spread = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

module.exports = defaultAxios;
module.exports.default = defaultAxios;
module.exports.AxiosError = AxiosError;
module.exports.InterceptorManager = InterceptorManager;
module.exports.create = defaultAxios.create;
